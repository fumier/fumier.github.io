{"meta":{"title":"Qian's Note","subtitle":"要当凌云须举翼，何妨随处一开颜","description":"Android开发工程师","author":"程倩<fumier@163.com>","url":"http://fumier.github.io","root":"/"},"pages":[{"title":"关于我","date":"2019-05-26T14:45:36.000Z","updated":"2019-05-26T09:42:08.875Z","comments":true,"path":"about/index.html","permalink":"http://fumier.github.io/about/index.html","excerpt":"","text":"职业: Android Developer 邮箱: fumier@163.com"}],"posts":[{"title":"LeetCode2_Add Two Numbers","slug":"LeetCode2-Add-Two-Numbers","date":"2019-06-08T12:14:00.000Z","updated":"2019-06-08T05:16:49.208Z","comments":true,"path":"2019/06/08/LeetCode2-Add-Two-Numbers/","link":"","permalink":"http://fumier.github.io/2019/06/08/LeetCode2-Add-Two-Numbers/","excerpt":"","text":"题目简析两个数存储在链表中，倒序排列的，分别相加，返回一个链表 算法详情：Add Two Numbers 这道题的考察有两点： 链表指针的处理 两数相加进位的处理 我的实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; if(l1==null&amp;&amp;l2==null)&#123; return l1; &#125; if(l1==null)&#123; return l2; &#125; if(l2==null)&#123; return l1; &#125; int rest=0; ListNode result=null; boolean firstNode=false; ListNode resultHeader=null; ListNode resultPointer=null; int value=0; while(l1!=null&amp;&amp;l2!=null)&#123; value=l1.val+l2.val+rest; rest=value&gt;9?1:0; value=value%10; result=new ListNode(value); if(!firstNode)&#123; resultHeader=result; resultPointer=resultHeader; firstNode=true; &#125;else&#123; resultPointer.next=result; resultPointer=result; &#125; l1=l1.next; l2=l2.next; &#125; if(l1!=null||l2!=null)&#123; if(l2==null)&#123; while(l1!=null)&#123; result=new ListNode(0); value=l1.val+rest; rest=value&gt;9?1:0; value=value%10; l1=l1.next; result.val=value; resultPointer.next=result; resultPointer=result; &#125; &#125;else&#123; while(l2!=null)&#123; result=new ListNode(0); value=l2.val+rest; rest=value&gt;9?1:0; value=value%10; l2=l2.next; result.val=value; resultPointer.next=result; resultPointer=result; &#125; &#125; &#125; if(rest!=0)&#123; result=new ListNode(rest); resultPointer.next=result; &#125; return resultHeader; &#125;&#125; 参考答案12345678910111213141516171819public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummyHead = new ListNode(0); ListNode p = l1, q = l2, curr = dummyHead; int carry = 0; while (p != null || q != null) &#123; int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; &#125; if (carry &gt; 0) &#123; curr.next = new ListNode(carry); &#125; return dummyHead.next;&#125; 分析 解题思路差不多，但是处理细节上，参考答案处理上更好一些。 链表长短不一致时，循环的处理，都放在一起处理，而我的分开处理了。导致代码有点冗余了 参考答案，设置了一个空Node，返回数据时，返回这个Node的next即可。避免了我在循环内部设置变量，用来控制对头结点的处理。","categories":[{"name":"算法","slug":"算法","permalink":"http://fumier.github.io/categories/算法/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://fumier.github.io/tags/LeetCode/"}]},{"title":"动态代理模式","slug":"代理模式","date":"2019-06-02T22:39:23.000Z","updated":"2019-06-02T15:01:49.974Z","comments":true,"path":"2019/06/03/代理模式/","link":"","permalink":"http://fumier.github.io/2019/06/03/代理模式/","excerpt":"","text":"本文旨在分析动态代理模式，其含义，应用场景以及实现原理。 什么是动态代理模式？代理模式：给目标对象提供一个代理对象，并由代理对象持有目标对象，来控制目标对象的访问。使用代理模式的好处是：在不改变目标对象方法的情况下，对方法进行增强。 静态代理&amp;Demo为什么有静态代理了还需要动态代理？ 静态代理类在编译期就已经确定，也就是有多个接口时，就要新建多个代理类。类增多，繁琐。 动态代理&amp;Demo动态代理源码分析参考链接 Java动态代理-实战","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://fumier.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://fumier.github.io/tags/设计模式/"}]},{"title":"ThreadLocal学习","slug":"ThreadLocal学习","date":"2019-06-02T15:27:48.000Z","updated":"2019-06-02T09:28:05.222Z","comments":true,"path":"2019/06/02/ThreadLocal学习/","link":"","permalink":"http://fumier.github.io/2019/06/02/ThreadLocal学习/","excerpt":"","text":"为什么用ThreadLocal在多线程的环境下，每个线程都有自己的数据。线程使用局部变量肯定比使用全局变量好。使用全局变量，一不小心就会引发线程安全问题，全局变量的修改必须加锁。而局部变量只有线程自己能看见，不会影响其他线程。但是局部变量有个缺点，如果别的函数也要使用，在函数调用的时候，需要通过参数的方式进行层层传递。有没有更简单的方式，不需要传递，也能解决多线程安全问题。ThreadLocal为此而生。 什么是ThreadLocal当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。 例子初始化15个线程，每个线程都有自己的map，往map中写入20个值。 123456789101112131415161718192021222324252627282930313233343536373839404142public class ThreadLocalTest implements Runnable &#123; int id; private static final ThreadLocal&lt;HashMap&gt; threadLocal = new ThreadLocal&lt;HashMap&gt;() &#123; @Override protected HashMap initialValue() &#123; return new HashMap(); &#125; &#125;; public ThreadLocalTest(int id) &#123; this.id = id; &#125; public void run() &#123; Map map=threadLocal.get(); for (int i = 0; i &lt; 20; i++) &#123; map.put(i, i + id * 100); try &#123; Thread.sleep(100); &#125; catch (Exception e) &#123; &#125; &#125; printMap(); &#125; public void printMap()&#123;//不需要传递参数 Map map=threadLocal.get(); System.out.println(Thread.currentThread().getName() + \"#map.size()\" + map.size() + \"#\" + map); &#125; public static void main(String[] args) &#123; Thread[] runs = new Thread[15]; ThreadLocalTest runnableTest = new ThreadLocalTest(1); for (int i = 0; i &lt; runs.length; i++) &#123; runs[i] = new Thread(runnableTest); &#125; for (int i = 0; i &lt; runs.length; i++) &#123; runs[i].start(); &#125; &#125;&#125; 源码分析核心类&amp;核心方法1.ThreadLocalMap2.T get() 获取当前线程的副本变量值3.void set(T value) 保存当前线程的副本变量值4.void remove() 移除当前前程的副本变量值 ThreadLocalMap12345678910111213141516171819202122232425262728293031323334353637383940414243static class ThreadLocalMap &#123;//ThreadLocal的内部静态类， /** * The entries in this hash map extend WeakReference, using * its main ref field as the key (which is always a * ThreadLocal object). Note that null keys (i.e. entry.get() * == null) mean that the key is no longer referenced, so the * entry can be expunged from table. Such entries are referred to * as \"stale entries\" in the code that follows. */ static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;//Entry继承WeakReference，它将以弱引用的方式被持有。 //内部静态类以及弱引用都是防止内存泄漏的有效方式。 /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125; &#125; ...... //构造方法，初始化相关信息 ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123; table = new Entry[INITIAL_CAPACITY]; //threadLocalHashCode&amp;(INITIAL_CAPACITY - 1)，目的是让i小于数组长度。如果每个线程只存一个变量，那么一个key都是一样的。多个变量ThreadLocal变多，要考虑到初始长度。 int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY); &#125; ...... private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123; int i = key.threadLocalHashCode &amp; (table.length - 1); Entry e = table[i]; if (e != null &amp;&amp; e.get() == key)//如果有直接获取 return e; else return getEntryAfterMiss(key, i, e); //如果插入的过程中，产生冲突，这里解决Hash冲突的方式不是链表的方式，而是采用线性探测的方式，根据初始key的hashcode值确定元素在table数组中的位置，如果发现这个位置上已经有其他key值的元素被占用，则利用固定的算法寻找一定步长的下个位置，依次判断，直至找到能够存放的位置。 &#125;&#125; ThreadLocal核心方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class ThreadLocal&lt;T&gt; &#123; public void set(T value) &#123; Thread t = Thread.currentThread();//获取当前线程 ThreadLocalMap map = getMap(t);//返回的是thread.threadLocals if (map != null) map.set(this, value); else createMap(t, value); &#125; /** * Get the map associated with a ThreadLocal. Overridden in * InheritableThreadLocal. * * @param t the current thread * @return the map */ ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals; &#125; /** * Create the map associated with a ThreadLocal. Overridden in * InheritableThreadLocal. * * @param t the current thread * @param firstValue value for the initial entry of the map */ void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue); &#125; public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this);//获取Entry if (e != null) &#123; @SuppressWarnings(\"unchecked\") T result = (T)e.value;//key是ThreadLocal的hashcode,value是要维护的值 return result; &#125; &#125; return setInitialValue(); &#125; /** * Variant of set() to establish initialValue. Used instead * of set() in case user has overridden the set() method. * * @return the initial value */ private T setInitialValue() &#123; T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value; &#125;&#125; 参考1.ThreadLocal-面试必问深度解析2.threadlocal使用","categories":[{"name":"线程","slug":"线程","permalink":"http://fumier.github.io/categories/线程/"}],"tags":[{"name":"线程安全","slug":"线程安全","permalink":"http://fumier.github.io/tags/线程安全/"}]},{"title":"旅游资讯20190526","slug":"旅游资讯20190526","date":"2019-05-26T23:06:23.000Z","updated":"2019-06-02T09:30:45.097Z","comments":true,"path":"2019/05/27/旅游资讯20190526/","link":"","permalink":"http://fumier.github.io/2019/05/27/旅游资讯20190526/","excerpt":"","text":"新闻15月23日，马蜂窝旅游网宣布完成由腾讯领投的2.5亿美元新一轮融资。 文章分析马蜂窝的蜜，腾讯的局 屡陷风波的马蜂窝为何频受腾讯青睐？腾讯又在布一个怎样的局？马蜂窝创立于2006年，2010年开始公司化运营。基于十多年的积累，马蜂窝已形成以数据驱动，以UGC(用户生产内容)为核心的“内容+交易”旅游社交平台。而这一独特的模式，也为腾讯后续的投资提供了可能。一方面，以UGC为主的内容不仅丰富了与传统OTA所不同的创新玩法，UGC模式更激发了用户的创造、分享热情，使得平台汇聚了高忠诚度的用户，最终形成一个活跃的旅游社区，与长于流量的腾讯有了可以交互连接的可能。另一方面，交易模式又使得马蜂窝在内容、社交之外拥有变现的入口，精准的高粘性用户和社交流量的价值为其预订、购票、营销等变现途径提供了保障。腾讯的旅游体系中，仍然缺少优质的UGC和旅游社交平台。而马蜂窝的存在恰好弥补了这个缺口，满足腾讯想要在旅游产业面面俱到的愿望。同时，马蜂窝的内容优势可以为用户提供很好的旅游决策和旅行计划，但马蜂窝的短板也很突出：过重的内容社交弱化了交易属性，而交易又是OTA平台变现的最佳途径。于是与同程艺龙的连接水到渠成，两者的互补形成了在线旅游的交易闭环，凭借微信的流量导入，将在增量市场焕发巨大的活力。此外，两者的增长又将进一步反哺微信的用户活跃与增长。 PS 腾讯对OTA有野心，在OTA领域进行了重要布局。 马蜂窝，用户粘性高，具有社交属性，变现能力还有待观察。 与同程艺龙的连接，收益能Double吗？存疑？","categories":[{"name":"资讯","slug":"资讯","permalink":"http://fumier.github.io/categories/资讯/"}],"tags":[{"name":"旅游资讯","slug":"旅游资讯","permalink":"http://fumier.github.io/tags/旅游资讯/"}]},{"title":"重新出发","slug":"重新出发","date":"2019-05-26T12:47:37.000Z","updated":"2019-05-26T09:02:59.721Z","comments":true,"path":"2019/05/26/重新出发/","link":"","permalink":"http://fumier.github.io/2019/05/26/重新出发/","excerpt":"","text":"隔了很久，都没有写过博客。这一次，我要重新出发。阅读书籍，整理文字，积累知识，记录自己学习的足迹。 TODO 设立目标 制定计划 定期复盘 调整计划 实现目标 其他 主题选用:maupassant，详情请见:https://www.haomwei.com/technology/maupassant-hexo.html","categories":[{"name":"生活","slug":"生活","permalink":"http://fumier.github.io/categories/生活/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://fumier.github.io/tags/生活/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-05-25T10:04:59.326Z","updated":"2019-05-25T10:04:59.326Z","comments":true,"path":"2019/05/25/hello-world/","link":"","permalink":"http://fumier.github.io/2019/05/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}